---
name: stats-database
status: closed
priority: high
github: https://github.com/javikin/umbral/issues/44
created: 2026-01-06T02:54:04Z
updated: 2026-01-06T04:03:42Z
depends_on: []
parallel: true
---

# Task 5: Stats Database Schema

## Objetivo

Crear el schema de base de datos para almacenar eventos de bloqueo y estadísticas.

## Implementación

### 1. Crear BlockingEvent Entity

```kotlin
// data/local/entity/BlockingEvent.kt
package com.umbral.data.local.entity

import androidx.room.Entity
import androidx.room.ForeignKey
import androidx.room.Index
import androidx.room.PrimaryKey

@Entity(
    tableName = "blocking_events",
    indices = [
        Index("timestamp"),
        Index("eventType"),
        Index("profileId")
    ],
    foreignKeys = [
        ForeignKey(
            entity = BlockingProfile::class,
            parentColumns = ["id"],
            childColumns = ["profileId"],
            onDelete = ForeignKey.SET_NULL
        )
    ]
)
data class BlockingEvent(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,
    val timestamp: Long = System.currentTimeMillis(),
    val eventType: EventType,
    val profileId: Long? = null,
    val packageName: String? = null,
    val durationMinutes: Int? = null
)

enum class EventType {
    BLOCK_STARTED,    // Bloqueo iniciado
    BLOCK_ENDED,      // Bloqueo terminado (incluye duración)
    APP_ATTEMPT       // Intento de abrir app bloqueada
}
```

### 2. Crear BlockingEventDao

```kotlin
// data/local/dao/BlockingEventDao.kt
package com.umbral.data.local.dao

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.Query
import kotlinx.coroutines.flow.Flow

@Dao
interface BlockingEventDao {

    @Insert
    suspend fun insert(event: BlockingEvent)

    // === Estadísticas de tiempo bloqueado ===

    @Query("""
        SELECT COALESCE(SUM(durationMinutes), 0)
        FROM blocking_events
        WHERE eventType = 'BLOCK_ENDED'
        AND timestamp >= :startTimestamp
    """)
    suspend fun getTotalBlockedMinutes(startTimestamp: Long): Int

    @Query("""
        SELECT COALESCE(SUM(durationMinutes), 0)
        FROM blocking_events
        WHERE eventType = 'BLOCK_ENDED'
        AND timestamp >= :startTimestamp
        AND timestamp < :endTimestamp
    """)
    suspend fun getBlockedMinutesBetween(startTimestamp: Long, endTimestamp: Long): Int

    // === Estadísticas de intentos ===

    @Query("""
        SELECT COUNT(*)
        FROM blocking_events
        WHERE eventType = 'APP_ATTEMPT'
        AND timestamp >= :startTimestamp
    """)
    suspend fun getAttemptCount(startTimestamp: Long): Int

    @Query("""
        SELECT packageName, COUNT(*) as count
        FROM blocking_events
        WHERE eventType = 'APP_ATTEMPT'
        AND timestamp >= :startTimestamp
        AND packageName IS NOT NULL
        GROUP BY packageName
        ORDER BY count DESC
        LIMIT :limit
    """)
    suspend fun getTopAttemptedApps(startTimestamp: Long, limit: Int = 5): List<AppAttemptCount>

    // === Estadísticas por día (para gráficas) ===

    @Query("""
        SELECT
            date(timestamp / 1000, 'unixepoch', 'localtime') as day,
            SUM(durationMinutes) as minutes
        FROM blocking_events
        WHERE eventType = 'BLOCK_ENDED'
        AND timestamp >= :startTimestamp
        GROUP BY day
        ORDER BY day
    """)
    suspend fun getDailyBlockedMinutes(startTimestamp: Long): List<DailyStats>

    // === Intentos por hora (para patrones) ===

    @Query("""
        SELECT
            strftime('%H', timestamp / 1000, 'unixepoch', 'localtime') as hour,
            COUNT(*) as count
        FROM blocking_events
        WHERE eventType = 'APP_ATTEMPT'
        AND timestamp >= :startTimestamp
        GROUP BY hour
        ORDER BY hour
    """)
    suspend fun getHourlyAttempts(startTimestamp: Long): List<HourlyStats>

    // === Flow para observar cambios ===

    @Query("SELECT COUNT(*) FROM blocking_events WHERE timestamp >= :startTimestamp")
    fun observeEventCount(startTimestamp: Long): Flow<Int>
}

data class AppAttemptCount(
    val packageName: String,
    val count: Int
)

data class DailyStats(
    val day: String,
    val minutes: Int
)

data class HourlyStats(
    val hour: String,
    val count: Int
)
```

### 3. Actualizar UmbralDatabase

```kotlin
// Agregar a UmbralDatabase.kt
@Database(
    entities = [
        BlockingProfile::class,
        // ... otras entities
        BlockingEvent::class  // NUEVO
    ],
    version = X, // Incrementar versión
    exportSchema = true
)
abstract class UmbralDatabase : RoomDatabase() {
    abstract fun blockingEventDao(): BlockingEventDao
    // ... otros DAOs
}
```

### 4. Crear Migración

```kotlin
// data/local/migration/Migration_X_Y.kt
val MIGRATION_X_Y = object : Migration(X, Y) {
    override fun migrate(database: SupportSQLiteDatabase) {
        database.execSQL("""
            CREATE TABLE IF NOT EXISTS blocking_events (
                id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
                timestamp INTEGER NOT NULL,
                eventType TEXT NOT NULL,
                profileId INTEGER,
                packageName TEXT,
                durationMinutes INTEGER,
                FOREIGN KEY (profileId) REFERENCES blocking_profiles(id) ON DELETE SET NULL
            )
        """)
        database.execSQL("CREATE INDEX IF NOT EXISTS index_blocking_events_timestamp ON blocking_events(timestamp)")
        database.execSQL("CREATE INDEX IF NOT EXISTS index_blocking_events_eventType ON blocking_events(eventType)")
        database.execSQL("CREATE INDEX IF NOT EXISTS index_blocking_events_profileId ON blocking_events(profileId)")
    }
}
```

### 5. Crear StatsRepository

```kotlin
// data/repository/StatsRepositoryImpl.kt
package com.umbral.data.repository

import com.umbral.data.local.dao.BlockingEventDao
import com.umbral.data.local.entity.BlockingEvent
import com.umbral.data.local.entity.EventType
import com.umbral.domain.repository.StatsRepository
import java.time.LocalDate
import java.time.LocalDateTime
import java.time.ZoneId
import javax.inject.Inject

class StatsRepositoryImpl @Inject constructor(
    private val blockingEventDao: BlockingEventDao
) : StatsRepository {

    override suspend fun recordBlockStarted(profileId: Long) {
        blockingEventDao.insert(
            BlockingEvent(
                eventType = EventType.BLOCK_STARTED,
                profileId = profileId
            )
        )
    }

    override suspend fun recordBlockEnded(profileId: Long, durationMinutes: Int) {
        blockingEventDao.insert(
            BlockingEvent(
                eventType = EventType.BLOCK_ENDED,
                profileId = profileId,
                durationMinutes = durationMinutes
            )
        )
    }

    override suspend fun recordAppAttempt(packageName: String) {
        blockingEventDao.insert(
            BlockingEvent(
                eventType = EventType.APP_ATTEMPT,
                packageName = packageName
            )
        )
    }

    override suspend fun getTodayStats(): TodayStats {
        val startOfDay = LocalDate.now()
            .atStartOfDay(ZoneId.systemDefault())
            .toInstant()
            .toEpochMilli()

        return TodayStats(
            blockedMinutes = blockingEventDao.getTotalBlockedMinutes(startOfDay),
            attemptCount = blockingEventDao.getAttemptCount(startOfDay)
        )
    }

    override suspend fun getWeeklyStats(): WeeklyStats {
        val startOfWeek = LocalDate.now()
            .minusDays(6)
            .atStartOfDay(ZoneId.systemDefault())
            .toInstant()
            .toEpochMilli()

        val startOfPreviousWeek = LocalDate.now()
            .minusDays(13)
            .atStartOfDay(ZoneId.systemDefault())
            .toInstant()
            .toEpochMilli()

        val thisWeekMinutes = blockingEventDao.getTotalBlockedMinutes(startOfWeek)
        val previousWeekMinutes = blockingEventDao.getBlockedMinutesBetween(
            startOfPreviousWeek,
            startOfWeek
        )

        return WeeklyStats(
            totalMinutes = thisWeekMinutes,
            previousWeekMinutes = previousWeekMinutes,
            dailyStats = blockingEventDao.getDailyBlockedMinutes(startOfWeek),
            topApps = blockingEventDao.getTopAttemptedApps(startOfWeek)
        )
    }
}

data class TodayStats(
    val blockedMinutes: Int,
    val attemptCount: Int
)

data class WeeklyStats(
    val totalMinutes: Int,
    val previousWeekMinutes: Int,
    val dailyStats: List<DailyStats>,
    val topApps: List<AppAttemptCount>
)
```

## Criterio de Done

- [ ] Entity BlockingEvent creada
- [ ] DAO con queries necesarios
- [ ] Migración de base de datos
- [ ] StatsRepository implementado
- [ ] Tests unitarios para DAO

## Estimación

~3 horas
