---
name: Repository y UseCases
status: open
created: 2026-01-07T20:19:34Z
updated: 2026-01-07T20:28:45Z
github: https://github.com/javikin/umbral/issues/66
depends_on: [65]
parallel: false
conflicts_with: [65]
---

# Task: Repository y UseCases

## Description

Crear el `NotificationRepository` que abstrae el acceso a datos y los UseCases del dominio para operaciones de negocio como guardar notificaciones, obtener resúmenes, y limpiar datos antiguos.

## Acceptance Criteria

- [ ] `NotificationRepository` con operaciones CRUD
- [ ] `SaveBlockedNotificationUseCase` para guardar notificaciones
- [ ] `GetNotificationSummaryUseCase` para resumen post-sesión
- [ ] `GetNotificationHistoryUseCase` para pantalla de historial
- [ ] `ClearOldNotificationsUseCase` para limpieza automática
- [ ] Domain model `BlockedNotification` separado de Entity
- [ ] Mapper Entity ↔ Domain model
- [ ] Inyección de dependencias con Hilt

## Technical Details

### Files to Create
```
app/src/main/java/com/umbral/notifications/
├── domain/
│   ├── model/
│   │   ├── BlockedNotification.kt
│   │   └── NotificationSummary.kt
│   ├── repository/
│   │   └── NotificationRepository.kt
│   └── usecase/
│       ├── SaveBlockedNotificationUseCase.kt
│       ├── GetNotificationSummaryUseCase.kt
│       ├── GetNotificationHistoryUseCase.kt
│       └── ClearOldNotificationsUseCase.kt
├── data/
│   └── repository/
│       └── NotificationRepositoryImpl.kt
└── di/
    └── NotificationModule.kt
```

### Domain Models
```kotlin
data class BlockedNotification(
    val id: Long = 0,
    val sessionId: String,
    val packageName: String,
    val appName: String,
    val title: String?,
    val text: String?,
    val timestamp: Instant,
    val iconUri: String?,
    val isRead: Boolean = false
)

data class NotificationSummary(
    val sessionId: String,
    val totalCount: Int,
    val byApp: List<AppCount>,
    val sessionDuration: Duration
) {
    data class AppCount(
        val packageName: String,
        val appName: String,
        val count: Int
    )
}
```

### Repository Interface
```kotlin
interface NotificationRepository {
    suspend fun save(notification: BlockedNotification): Long
    fun getBySession(sessionId: String): Flow<List<BlockedNotification>>
    fun getRecent(limit: Int = 100): Flow<List<BlockedNotification>>
    suspend fun getSummaryForSession(sessionId: String): NotificationSummary
    suspend fun getTotalBlockedCount(): Int
    suspend fun markAsRead(id: Long)
    suspend fun delete(id: Long)
    suspend fun clearOlderThan(days: Int)
    suspend fun trimToLimit(maxCount: Int = 1000)
}
```

### Repository Implementation
```kotlin
class NotificationRepositoryImpl @Inject constructor(
    private val dao: BlockedNotificationDao
) : NotificationRepository {

    override suspend fun save(notification: BlockedNotification): Long {
        return dao.insert(notification.toEntity())
    }

    override fun getBySession(sessionId: String): Flow<List<BlockedNotification>> {
        return dao.getBySession(sessionId).map { entities ->
            entities.map { it.toDomain() }
        }
    }

    override suspend fun getSummaryForSession(sessionId: String): NotificationSummary {
        val count = dao.getCountForSession(sessionId)
        val byApp = dao.getCountByAppForSession(sessionId)
        return NotificationSummary(
            sessionId = sessionId,
            totalCount = count,
            byApp = byApp.map { NotificationSummary.AppCount(it.packageName, it.appName, it.count) },
            sessionDuration = Duration.ZERO // Will be calculated with session data
        )
    }

    override suspend fun clearOlderThan(days: Int) {
        val cutoff = System.currentTimeMillis() - (days * 24 * 60 * 60 * 1000L)
        dao.deleteOlderThan(cutoff)
    }

    override suspend fun trimToLimit(maxCount: Int) {
        dao.trimToLimit(maxCount)
    }
}
```

### UseCases
```kotlin
class SaveBlockedNotificationUseCase @Inject constructor(
    private val repository: NotificationRepository
) {
    suspend operator fun invoke(notification: BlockedNotification): Long {
        val id = repository.save(notification)
        // Trim to limit after save
        repository.trimToLimit(1000)
        return id
    }
}

class GetNotificationSummaryUseCase @Inject constructor(
    private val repository: NotificationRepository
) {
    suspend operator fun invoke(sessionId: String): NotificationSummary {
        return repository.getSummaryForSession(sessionId)
    }
}

class ClearOldNotificationsUseCase @Inject constructor(
    private val repository: NotificationRepository
) {
    suspend operator fun invoke(retentionDays: Int = 7) {
        repository.clearOlderThan(retentionDays)
    }
}
```

### Hilt Module
```kotlin
@Module
@InstallIn(SingletonComponent::class)
abstract class NotificationModule {

    @Binds
    @Singleton
    abstract fun bindNotificationRepository(
        impl: NotificationRepositoryImpl
    ): NotificationRepository
}
```

## Dependencies

- [ ] Task 003 - Room entity and DAO must exist
- [ ] Hilt (already in project)

## Effort Estimate

- Size: M
- Hours: 3
- Parallel: false (depends on 003)

## Definition of Done

- [ ] Repository implements all required operations
- [ ] UseCases encapsulate business logic
- [ ] Domain models are clean and separate from entities
- [ ] Hilt injection works correctly
- [ ] Unit tests for repository and usecases
