---
name: Integración BlockingManager
status: open
created: 2026-01-07T20:19:34Z
updated: 2026-01-07T20:28:45Z
github: https://github.com/javikin/umbral/issues/69
depends_on: [63, 64, 66]
parallel: false
conflicts_with: []
---

# Task: Integración BlockingManager

## Description

Conectar el `UmbralNotificationService` con el `BlockingManager` existente para que las notificaciones solo se intercepten cuando hay una sesión de bloqueo activa, y solo para las apps que están en el perfil de bloqueo activo.

## Acceptance Criteria

- [ ] Service consulta `BlockingManager.isBlocking` antes de filtrar
- [ ] Service obtiene lista de apps bloqueadas del perfil activo
- [ ] Notificaciones se guardan con el `sessionId` correcto
- [ ] Cuando termina sesión, se dispara el Summary dialog
- [ ] Service maneja correctamente inicio/fin de sesiones
- [ ] Service sobrevive a reinicios del sistema
- [ ] Graceful handling cuando servicio es terminado por OEM

## Technical Details

### Files to Modify
```
app/src/main/java/com/umbral/notifications/service/
└── UmbralNotificationService.kt (major modifications)

app/src/main/java/com/umbral/blocking/domain/
└── BlockingManager.kt (add notification callbacks)
```

### Service Integration
```kotlin
@AndroidEntryPoint
class UmbralNotificationService : NotificationListenerService() {

    @Inject
    lateinit var blockingManager: BlockingManager

    @Inject
    lateinit var saveNotificationUseCase: SaveBlockedNotificationUseCase

    @Inject
    lateinit var notificationPreferences: NotificationPreferences

    private var currentSessionId: String? = null
    private var blockedApps: Set<String> = emptySet()

    private val serviceScope = CoroutineScope(Dispatchers.IO + SupervisorJob())

    override fun onCreate() {
        super.onCreate()
        observeBlockingState()
    }

    private fun observeBlockingState() {
        serviceScope.launch {
            blockingManager.blockingState.collect { state ->
                when (state) {
                    is BlockingState.Active -> {
                        currentSessionId = state.sessionId
                        blockedApps = state.blockedApps
                    }
                    is BlockingState.Inactive -> {
                        currentSessionId = null
                        blockedApps = emptySet()
                    }
                }
            }
        }
    }

    override fun onNotificationPosted(sbn: StatusBarNotification?) {
        sbn ?: return

        // Only process if blocking is active
        val sessionId = currentSessionId ?: return

        // Check whitelist first
        if (shouldAllowNotification(sbn)) return

        // Check if app is in blocked list
        if (sbn.packageName !in blockedApps) return

        // Block and store the notification
        serviceScope.launch {
            storeAndCancelNotification(sbn, sessionId)
        }
    }

    private suspend fun storeAndCancelNotification(
        sbn: StatusBarNotification,
        sessionId: String
    ) {
        val notification = BlockedNotification(
            sessionId = sessionId,
            packageName = sbn.packageName,
            appName = getAppName(sbn.packageName),
            title = sbn.notification.extras.getString(Notification.EXTRA_TITLE),
            text = sbn.notification.extras.getString(Notification.EXTRA_TEXT),
            timestamp = Instant.now(),
            iconUri = null // Can extract icon later
        )

        saveNotificationUseCase(notification)

        // Cancel the notification to hide it
        cancelNotification(sbn.key)
    }

    private fun getAppName(packageName: String): String {
        return try {
            val appInfo = packageManager.getApplicationInfo(packageName, 0)
            packageManager.getApplicationLabel(appInfo).toString()
        } catch (e: PackageManager.NameNotFoundException) {
            packageName
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        serviceScope.cancel()
    }

    override fun onListenerConnected() {
        super.onListenerConnected()
        // Service connected to notification system
        Log.d(TAG, "NotificationListenerService connected")
    }

    override fun onListenerDisconnected() {
        super.onListenerDisconnected()
        // Try to rebind
        requestRebind(ComponentName(this, UmbralNotificationService::class.java))
    }

    companion object {
        private const val TAG = "UmbralNotificationSvc"
    }
}
```

### BlockingManager Updates
```kotlin
// Add to BlockingManager interface
interface BlockingManager {
    val blockingState: StateFlow<BlockingState>
    // ... existing methods
}

sealed class BlockingState {
    data class Active(
        val sessionId: String,
        val blockedApps: Set<String>,
        val profileName: String
    ) : BlockingState()

    object Inactive : BlockingState()
}

// Implementation
class BlockingManagerImpl @Inject constructor(
    // ... existing deps
) : BlockingManager {

    private val _blockingState = MutableStateFlow<BlockingState>(BlockingState.Inactive)
    override val blockingState: StateFlow<BlockingState> = _blockingState.asStateFlow()

    override fun startBlocking(profile: BlockingProfile) {
        val sessionId = UUID.randomUUID().toString()
        _blockingState.value = BlockingState.Active(
            sessionId = sessionId,
            blockedApps = profile.blockedApps.toSet(),
            profileName = profile.name
        )
        // ... existing logic
    }

    override fun stopBlocking() {
        // Emit event for session end (for Summary dialog)
        val currentState = _blockingState.value
        if (currentState is BlockingState.Active) {
            notifySessionEnded(currentState.sessionId)
        }
        _blockingState.value = BlockingState.Inactive
        // ... existing logic
    }
}
```

### Session End Event
```kotlin
// For triggering Summary dialog
class SessionEndedEvent(val sessionId: String)

// In BlockingManagerImpl
private val _sessionEndedEvents = MutableSharedFlow<SessionEndedEvent>()
val sessionEndedEvents: SharedFlow<SessionEndedEvent> = _sessionEndedEvents.asSharedFlow()

private fun notifySessionEnded(sessionId: String) {
    scope.launch {
        _sessionEndedEvents.emit(SessionEndedEvent(sessionId))
    }
}
```

### HomeScreen Integration
```kotlin
// In HomeScreen or HomeViewModel
LaunchedEffect(Unit) {
    blockingManager.sessionEndedEvents.collect { event ->
        // Show summary dialog
        showSessionSummary = true
        lastSessionId = event.sessionId
    }
}
```

### Service Resilience
```kotlin
// Handle OEM battery optimization killing the service
class ServiceRestartReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context, intent: Intent) {
        if (intent.action == Intent.ACTION_BOOT_COMPLETED) {
            // Check if notification listener is enabled
            if (NotificationPermissionHelper.isNotificationListenerEnabled(context)) {
                // Service will auto-restart, but we can trigger rebind
                val componentName = ComponentName(context, UmbralNotificationService::class.java)
                NotificationListenerService.requestRebind(componentName)
            }
        }
    }
}
```

## Dependencies

- [ ] Task 001 - Base NotificationListenerService
- [ ] Task 002 - Whitelist implementation
- [ ] Task 004 - Repository for saving notifications
- [ ] Existing BlockingManager in project

## Effort Estimate

- Size: L
- Hours: 4
- Parallel: false (critical integration)

## Definition of Done

- [ ] Service correctly queries blocking state
- [ ] Only notifications from blocked apps are intercepted
- [ ] SessionId is correctly associated with notifications
- [ ] Session end triggers summary dialog
- [ ] Service handles disconnection/reconnection
- [ ] Integration tests verify end-to-end flow
