---
name: Integración gamificación + achievements
status: open
created: 2026-01-07T20:19:34Z
updated: 2026-01-07T20:28:45Z
github: https://github.com/javikin/umbral/issues/70
depends_on: [66, 69]
parallel: false
conflicts_with: []
---

# Task: Integración gamificación + achievements

## Description

Integrar el sistema de notificaciones bloqueadas con el sistema de gamificación existente (Expedición). Incluye otorgar energía bonus por notificaciones bloqueadas y agregar nuevos logros relacionados con el bloqueo de notificaciones.

## Acceptance Criteria

- [ ] +1 energía por cada 5 notificaciones bloqueadas en sesión
- [ ] Energía bonus se otorga al terminar sesión
- [ ] Nuevo logro: "Escudo Mental" (bloquear 100 notificaciones)
- [ ] Nuevo logro: "Fortaleza" (bloquear 500 notificaciones)
- [ ] Nuevo logro: "Inmune" (bloquear 1000 notificaciones)
- [ ] Stats de notificaciones en pantalla de estadísticas
- [ ] Achievement check automático al guardar notificación
- [ ] Animación de logro desbloqueado

## Technical Details

### Files to Create/Modify
```
app/src/main/java/com/umbral/expedition/domain/model/
└── Achievement.kt (add new achievements)

app/src/main/java/com/umbral/expedition/data/
└── AchievementDefinitions.kt (add new definitions)

app/src/main/java/com/umbral/notifications/domain/usecase/
└── GrantNotificationRewardsUseCase.kt

app/src/main/java/com/umbral/stats/
└── (add notification stats)
```

### New Achievement Definitions
```kotlin
// In AchievementDefinitions.kt
object NotificationAchievements {
    val SHIELD_MIND = AchievementDefinition(
        id = "shield_mind",
        name = "Escudo Mental",
        description = "Bloquea 100 notificaciones",
        iconRes = R.drawable.ic_achievement_shield,
        category = AchievementCategory.NOTIFICATIONS,
        requirement = AchievementRequirement.BlockNotifications(100),
        energyReward = 50
    )

    val FORTRESS = AchievementDefinition(
        id = "fortress",
        name = "Fortaleza",
        description = "Bloquea 500 notificaciones",
        iconRes = R.drawable.ic_achievement_fortress,
        category = AchievementCategory.NOTIFICATIONS,
        requirement = AchievementRequirement.BlockNotifications(500),
        energyReward = 100
    )

    val IMMUNE = AchievementDefinition(
        id = "immune",
        name = "Inmune",
        description = "Bloquea 1000 notificaciones",
        iconRes = R.drawable.ic_achievement_immune,
        category = AchievementCategory.NOTIFICATIONS,
        requirement = AchievementRequirement.BlockNotifications(1000),
        energyReward = 200
    )

    val ALL = listOf(SHIELD_MIND, FORTRESS, IMMUNE)
}

// Add to AchievementCategory
enum class AchievementCategory {
    FOCUS,
    STREAKS,
    EXPLORATION,
    NOTIFICATIONS  // NEW
}

// Add to AchievementRequirement
sealed class AchievementRequirement {
    // ... existing requirements
    data class BlockNotifications(val count: Int) : AchievementRequirement()
}
```

### Rewards UseCase
```kotlin
class GrantNotificationRewardsUseCase @Inject constructor(
    private val notificationRepository: NotificationRepository,
    private val expeditionRepository: ExpeditionRepository,
    private val achievementRepository: AchievementRepository
) {
    /**
     * Called when a blocking session ends.
     * Grants energy bonus and checks for achievement unlocks.
     */
    suspend operator fun invoke(sessionId: String): RewardResult {
        // 1. Get notification count for session
        val sessionCount = notificationRepository.getCountForSession(sessionId)

        // 2. Calculate energy bonus
        val bonusEnergy = sessionCount / 5  // +1 per 5 notifications

        // 3. Grant energy
        if (bonusEnergy > 0) {
            expeditionRepository.addEnergy(bonusEnergy)
        }

        // 4. Get total blocked notifications (lifetime)
        val totalBlocked = notificationRepository.getTotalBlockedCount()

        // 5. Check and unlock achievements
        val unlockedAchievements = mutableListOf<AchievementDefinition>()

        NotificationAchievements.ALL.forEach { achievement ->
            val requirement = achievement.requirement as? AchievementRequirement.BlockNotifications
            if (requirement != null && totalBlocked >= requirement.count) {
                val wasUnlocked = achievementRepository.unlockIfNew(achievement.id)
                if (wasUnlocked) {
                    unlockedAchievements.add(achievement)
                    // Grant achievement energy reward
                    expeditionRepository.addEnergy(achievement.energyReward)
                }
            }
        }

        return RewardResult(
            sessionNotifications = sessionCount,
            bonusEnergy = bonusEnergy,
            totalBlocked = totalBlocked,
            unlockedAchievements = unlockedAchievements
        )
    }
}

data class RewardResult(
    val sessionNotifications: Int,
    val bonusEnergy: Int,
    val totalBlocked: Int,
    val unlockedAchievements: List<AchievementDefinition>
)
```

### Integration with Session End
```kotlin
// In BlockingManagerImpl or wherever session end is handled
class HandleSessionEndUseCase @Inject constructor(
    private val grantRewardsUseCase: GrantNotificationRewardsUseCase,
    private val sessionEndedEventBus: SessionEndedEventBus
) {
    suspend operator fun invoke(sessionId: String) {
        // Grant rewards
        val result = grantRewardsUseCase(sessionId)

        // Emit event with reward info for UI
        sessionEndedEventBus.emit(
            SessionEndedEvent(
                sessionId = sessionId,
                notificationCount = result.sessionNotifications,
                bonusEnergy = result.bonusEnergy,
                unlockedAchievements = result.unlockedAchievements
            )
        )
    }
}
```

### Stats Integration
```kotlin
// Add to StatsRepository or create NotificationStatsUseCase
class GetNotificationStatsUseCase @Inject constructor(
    private val notificationRepository: NotificationRepository
) {
    suspend operator fun invoke(): NotificationStats {
        val totalBlocked = notificationRepository.getTotalBlockedCount()
        val last7Days = notificationRepository.getCountForPeriod(days = 7)
        val topApps = notificationRepository.getTopBlockedApps(limit = 5)

        return NotificationStats(
            totalBlocked = totalBlocked,
            last7Days = last7Days,
            topApps = topApps
        )
    }
}

data class NotificationStats(
    val totalBlocked: Int,
    val last7Days: Int,
    val topApps: List<AppNotificationCount>
)
```

### StatsScreen Update
```kotlin
// Add section to StatsScreen
@Composable
fun NotificationStatsSection(stats: NotificationStats) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp)
    ) {
        Column(modifier = Modifier.padding(16.dp)) {
            Text(
                text = "Notificaciones Bloqueadas",
                style = MaterialTheme.typography.titleMedium
            )

            Spacer(modifier = Modifier.height(16.dp))

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
                StatItem(
                    value = stats.totalBlocked.toString(),
                    label = "Total"
                )
                StatItem(
                    value = stats.last7Days.toString(),
                    label = "Última semana"
                )
            }

            if (stats.topApps.isNotEmpty()) {
                Spacer(modifier = Modifier.height(16.dp))
                Text(
                    text = "Top Apps Distractoras",
                    style = MaterialTheme.typography.labelMedium
                )
                stats.topApps.forEach { app ->
                    Row(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(vertical = 4.dp),
                        horizontalArrangement = Arrangement.SpaceBetween
                    ) {
                        Text(app.appName)
                        Text(
                            "${app.count}",
                            fontWeight = FontWeight.Bold
                        )
                    }
                }
            }
        }
    }
}
```

### Achievement Animation
```kotlin
// Update AchievementUnlockedDialog to handle notification achievements
@Composable
fun AchievementUnlockedDialog(
    achievement: AchievementDefinition,
    onDismiss: () -> Unit
) {
    // Existing implementation with Lottie animation
    // Add notification-specific icon/animation if category is NOTIFICATIONS
}
```

## Dependencies

- [ ] Task 004 - Repository for notification counts
- [ ] Task 007 - BlockingManager integration for session events
- [ ] Existing ExpeditionRepository in project
- [ ] Existing AchievementSystem in project

## Effort Estimate

- Size: M
- Hours: 4
- Parallel: false (depends on integration task)

## Definition of Done

- [ ] Energy bonus correctly calculated and granted
- [ ] All 3 notification achievements defined
- [ ] Achievements unlock at correct thresholds
- [ ] Achievement rewards granted correctly
- [ ] Stats screen shows notification stats
- [ ] End-to-end flow tested (block → session end → rewards)
- [ ] Achievement unlock animation works for new achievements
