---
name: Agregar Animaciones y Micro-interacciones
status: closed
created: 2026-01-05T03:15:00Z
updated: 2026-01-05T03:15:00Z
github:
parallel: false
depends_on: [003, 004, 005, 006, 007, 008]
effort: 8h
---

# Task: Agregar Animaciones y Micro-interacciones

## Descripción

Pulir toda la app con animaciones consistentes y micro-interacciones que hagan la experiencia más agradable.

## Sistema de Animaciones

### Durations

```kotlin
object UmbralAnimation {
    val Quick = 150  // hover, press
    val Normal = 300 // transitions
    val Slow = 500   // page transitions

    val StandardEasing = CubicBezierEasing(0.4f, 0.0f, 0.2f, 1f)
    val DecelerateEasing = CubicBezierEasing(0.0f, 0.0f, 0.2f, 1f)
    val AccelerateEasing = CubicBezierEasing(0.4f, 0.0f, 1f, 1f)
}
```

## Micro-interacciones por Componente

### 1. Botones

```kotlin
@Composable
fun UmbralButton(...) {
    val interactionSource = remember { MutableInteractionSource() }
    val isPressed by interactionSource.collectIsPressedAsState()

    val scale by animateFloatAsState(
        targetValue = if (isPressed) 0.95f else 1f,
        animationSpec = spring(stiffness = Spring.StiffnessHigh)
    )

    Button(
        modifier = Modifier.scale(scale),
        interactionSource = interactionSource,
        ...
    )
}
```

### 2. Cards

```kotlin
@Composable
fun UmbralCard(...) {
    val isPressed by interactionSource.collectIsPressedAsState()

    val elevation by animateDpAsState(
        targetValue = if (isPressed) 2.dp else 4.dp
    )

    Card(
        elevation = CardDefaults.cardElevation(defaultElevation = elevation),
        ...
    )
}
```

### 3. Toggles

```kotlin
@Composable
fun UmbralToggle(...) {
    val thumbOffset by animateDpAsState(
        targetValue = if (checked) 20.dp else 0.dp,
        animationSpec = spring(
            dampingRatio = Spring.DampingRatioMediumBouncy,
            stiffness = Spring.StiffnessLow
        )
    )

    // Color transition
    val trackColor by animateColorAsState(
        targetValue = if (checked)
            MaterialTheme.colorScheme.primary
        else
            MaterialTheme.colorScheme.surfaceVariant
    )
}
```

### 4. Checkboxes

```kotlin
@Composable
fun AnimatedCheckbox(...) {
    val checkProgress by animateFloatAsState(
        targetValue = if (checked) 1f else 0f
    )

    Canvas(modifier) {
        // Draw check mark with progress
        val path = Path().apply {
            moveTo(size.width * 0.2f, size.height * 0.5f)
            lineTo(size.width * 0.4f, size.height * 0.7f)
            lineTo(size.width * 0.8f, size.height * 0.3f)
        }

        drawPath(
            path = path,
            color = Color.White,
            style = Stroke(
                width = 3.dp.toPx(),
                pathEffect = PathEffect.dashPathEffect(
                    floatArrayOf(
                        path.length * checkProgress,
                        path.length
                    )
                )
            )
        )
    }
}
```

### 5. Pull to Refresh

```kotlin
@Composable
fun UmbralPullRefresh(...) {
    val rotation by animateFloatAsState(
        targetValue = if (isRefreshing) 360f else 0f,
        animationSpec = infiniteRepeatable(
            animation = tween(1000, easing = LinearEasing)
        )
    )

    // Custom Umbral logo spinning
    Icon(
        painter = painterResource(R.drawable.ic_umbral_logo),
        modifier = Modifier.rotate(rotation)
    )
}
```

## Transiciones de Navegación

### Entre pantallas

```kotlin
// NavHost con animaciones
NavHost(
    navController = navController,
    enterTransition = {
        fadeIn(animationSpec = tween(UmbralAnimation.Normal)) +
        slideInHorizontally(initialOffsetX = { it / 4 })
    },
    exitTransition = {
        fadeOut(animationSpec = tween(UmbralAnimation.Normal)) +
        slideOutHorizontally(targetOffsetX = { -it / 4 })
    },
    popEnterTransition = {
        fadeIn(animationSpec = tween(UmbralAnimation.Normal)) +
        slideInHorizontally(initialOffsetX = { -it / 4 })
    },
    popExitTransition = {
        fadeOut(animationSpec = tween(UmbralAnimation.Normal)) +
        slideOutHorizontally(targetOffsetX = { it / 4 })
    }
)
```

### Shared Element Transitions (donde aplique)

```kotlin
// En pantallas con elementos compartidos
SharedTransitionLayout {
    AnimatedContent(targetState = currentScreen) { screen ->
        when (screen) {
            Screen.List -> ListScreen(
                onItemClick = { item ->
                    Modifier.sharedElement(
                        rememberSharedContentState("item-${item.id}"),
                        animatedVisibilityScope = this@AnimatedContent
                    )
                }
            )
            Screen.Detail -> DetailScreen(
                sharedModifier = Modifier.sharedElement(...)
            )
        }
    }
}
```

## Animaciones de Estado

### Loading States

```kotlin
@Composable
fun ShimmerLoading(modifier: Modifier) {
    val transition = rememberInfiniteTransition()
    val translateX by transition.animateFloat(
        initialValue = -1000f,
        targetValue = 1000f,
        animationSpec = infiniteRepeatable(
            animation = tween(1200, easing = LinearEasing)
        )
    )

    Box(
        modifier = modifier.background(
            brush = Brush.linearGradient(
                colors = listOf(
                    Color.LightGray.copy(alpha = 0.6f),
                    Color.LightGray.copy(alpha = 0.2f),
                    Color.LightGray.copy(alpha = 0.6f)
                ),
                start = Offset(translateX, 0f),
                end = Offset(translateX + 500f, 0f)
            )
        )
    )
}
```

### Empty States

```kotlin
@Composable
fun EmptyStateAnimation() {
    val composition by rememberLottieComposition(
        LottieCompositionSpec.RawRes(R.raw.empty_state)
    )
    val progress by animateLottieCompositionAsState(
        composition,
        iterations = LottieConstants.IterateForever
    )

    LottieAnimation(
        composition = composition,
        progress = { progress }
    )
}
```

### Success States

```kotlin
@Composable
fun SuccessCheckAnimation() {
    val composition by rememberLottieComposition(
        LottieCompositionSpec.RawRes(R.raw.success_check)
    )
    val progress by animateLottieCompositionAsState(
        composition,
        iterations = 1
    )

    LottieAnimation(
        composition = composition,
        progress = { progress }
    )
}
```

## Haptic Feedback

```kotlin
object UmbralHaptics {
    @Composable
    fun performClick() {
        val view = LocalView.current
        LaunchedEffect(Unit) {
            view.performHapticFeedback(HapticFeedbackConstants.CONTEXT_CLICK)
        }
    }

    @Composable
    fun performSuccess() {
        val view = LocalView.current
        LaunchedEffect(Unit) {
            view.performHapticFeedback(HapticFeedbackConstants.CONFIRM)
        }
    }
}
```

## Archivos a Crear/Modificar

- Crear: `UmbralAnimation.kt` - Constantes y specs
- Crear: `ShimmerLoading.kt`
- Crear: `AnimatedCheckbox.kt`
- Modificar: Todos los componentes base para agregar animaciones
- Modificar: `UmbralNavigation.kt` para transiciones

## Assets Lottie Necesarios

- `empty_state.json` - Animación de estado vacío
- `success_check.json` - Check de éxito
- `loading.json` - Loading spinner custom

## Criterios de Aceptación

- [ ] Todos los botones tienen press animation
- [ ] Cards responden al press con elevación
- [ ] Toggles con bounce animation
- [ ] Transiciones entre pantallas smooth
- [ ] Loading states con shimmer
- [ ] Haptic feedback en acciones principales
- [ ] 60fps en todas las animaciones
- [ ] No jank visible en transiciones
