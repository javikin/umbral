---
name: Domain models y UseCases
status: open
created: 2026-01-07T05:02:20Z
updated: 2026-01-07T05:13:26Z
github: https://github.com/javikin/umbral/issues/55
depends_on: [54]
parallel: false
conflicts_with: []
---

# Task: Domain models y UseCases

## Description

Crear los modelos de dominio (entities limpias sin dependencias de Room) y los casos de uso que encapsulan la lógica de negocio del sistema de gamificación.

## Acceptance Criteria

- [ ] Domain models creados (Companion, Location, Achievement, etc.)
- [ ] Enums para tipos (CompanionType, AchievementCategory, Biome)
- [ ] 6 UseCases principales implementados
- [ ] Mappers Entity ↔ Domain model
- [ ] Fórmulas de progresión encapsuladas
- [ ] Unit tests para UseCases

## Technical Details

### 1. Domain Models

```kotlin
// Companion.kt
data class Companion(
    val id: String,
    val type: CompanionType,
    val name: String?,
    val evolutionState: Int,
    val energyInvested: Int,
    val capturedAt: Long,
    val isActive: Boolean
) {
    val canEvolve: Boolean
        get() = evolutionState < 3 && energyInvested >= evolutionCost

    val evolutionCost: Int
        get() = ExpeditionFormulas.evolutionCost(evolutionState)

    val evolutionProgress: Float
        get() = (energyInvested.toFloat() / evolutionCost).coerceIn(0f, 1f)
}

// CompanionType.kt
enum class CompanionType(
    val displayName: String,
    val element: String,
    val passiveBonus: String,
    val captureRequirement: CaptureRequirement
) {
    LUMINA("Lumina", "Luz", "+5% XP", CaptureRequirement.Starter),
    TERRA("Terra", "Tierra", "+5% Energía", CaptureRequirement.Energy(500)),
    AQUA("Aqua", "Agua", "-10% tiempo evolución", CaptureRequirement.Location("lake")),
    VENTUS("Ventus", "Aire", "+1 día perdón racha", CaptureRequirement.Streak(7)),
    FLORA("Flora", "Planta", "-20% costo decoraciones", CaptureRequirement.Locations(10)),
    IGNIS("Ignis", "Fuego", "+10% Energía racha 5+", CaptureRequirement.Streak(14)),
    NOCTIS("Noctis", "Noche", "2x Energía nocturna", CaptureRequirement.NightSessions(10)),
    AURORA("Aurora", "Amanecer", "+50 bonus diario", CaptureRequirement.TotalDays(30))
}

sealed class CaptureRequirement {
    object Starter : CaptureRequirement()
    data class Energy(val amount: Int) : CaptureRequirement()
    data class Streak(val days: Int) : CaptureRequirement()
    data class Location(val locationId: String) : CaptureRequirement()
    data class Locations(val count: Int) : CaptureRequirement()
    data class NightSessions(val count: Int) : CaptureRequirement()
    data class TotalDays(val days: Int) : CaptureRequirement()
}
```

### 2. PlayerProgress Model

```kotlin
data class PlayerProgress(
    val level: Int,
    val currentXp: Int,
    val totalEnergy: Int,
    val stars: Int,
    val currentStreak: Int,
    val longestStreak: Int,
    val totalBlockingMinutes: Int
) {
    val xpForNextLevel: Int
        get() = ExpeditionFormulas.xpForLevel(level)

    val levelProgress: Float
        get() = currentXp.toFloat() / xpForNextLevel

    val streakMultiplier: Float
        get() = ExpeditionFormulas.getStreakMultiplier(currentStreak)
}
```

### 3. ExpeditionFormulas Object

```kotlin
object ExpeditionFormulas {
    const val BASE_ENERGY_PER_MINUTE = 10
    const val XP_PER_ENERGY = 1

    fun getStreakMultiplier(streak: Int): Float = when {
        streak < 3 -> 1.0f
        streak < 7 -> 1.25f
        streak < 14 -> 1.5f
        streak < 30 -> 2.0f
        else -> 2.5f
    }

    fun xpForLevel(level: Int): Int = (100 * level * 1.2).toInt()

    fun locationRevealCost(index: Int): Int = 200 + (index * 50)

    fun evolutionCost(currentState: Int): Int = when (currentState) {
        1 -> 1000
        2 -> 3000
        else -> Int.MAX_VALUE
    }

    fun calculateEnergy(minutes: Int, streakMultiplier: Float): Int {
        return (minutes * BASE_ENERGY_PER_MINUTE * streakMultiplier).toInt()
    }
}
```

### 4. UseCases

```kotlin
// GainEnergyUseCase.kt
class GainEnergyUseCase @Inject constructor(
    private val repository: ExpeditionRepository
) {
    suspend operator fun invoke(blockingMinutes: Int): EnergyGainResult {
        val progress = repository.getProgressSnapshot()
        val multiplier = ExpeditionFormulas.getStreakMultiplier(progress.currentStreak)
        val energyGained = ExpeditionFormulas.calculateEnergy(blockingMinutes, multiplier)

        repository.addEnergy(energyGained)
        repository.addXp(energyGained * ExpeditionFormulas.XP_PER_ENERGY)

        return EnergyGainResult(
            baseEnergy = blockingMinutes * ExpeditionFormulas.BASE_ENERGY_PER_MINUTE,
            multiplier = multiplier,
            totalEnergy = energyGained,
            xpGained = energyGained
        )
    }
}

// DiscoverLocationUseCase.kt
class DiscoverLocationUseCase @Inject constructor(
    private val repository: ExpeditionRepository
) {
    suspend operator fun invoke(locationId: String, biomeId: String): DiscoveryResult {
        val progress = repository.getProgressSnapshot()
        val discoveredCount = repository.getDiscoveryCount()
        val cost = ExpeditionFormulas.locationRevealCost(discoveredCount)

        if (progress.totalEnergy < cost) {
            return DiscoveryResult.InsufficientEnergy(cost, progress.totalEnergy)
        }

        repository.discoverLocation(locationId, biomeId, cost)
        repository.spendEnergy(cost)

        return DiscoveryResult.Success(locationId, cost)
    }
}

// EvolveCompanionUseCase.kt
class EvolveCompanionUseCase @Inject constructor(
    private val repository: ExpeditionRepository
) {
    suspend operator fun invoke(companionId: String): EvolutionResult {
        val companion = repository.getCompanionById(companionId)
            ?: return EvolutionResult.NotFound

        if (!companion.canEvolve) {
            return EvolutionResult.InsufficientEnergy(
                required = companion.evolutionCost,
                current = companion.energyInvested
            )
        }

        if (companion.evolutionState >= 3) {
            return EvolutionResult.MaxEvolution
        }

        repository.evolveCompanion(companionId)
        return EvolutionResult.Success(
            newState = companion.evolutionState + 1
        )
    }
}
```

## Dependencies

- [ ] Task 002 (Entities y DAOs) completado

## Effort Estimate

- Size: M
- Hours: 4
- Parallel: false

## Definition of Done

- [ ] Todos los domain models creados
- [ ] Enums con datos completos
- [ ] 6 UseCases implementados
- [ ] Mappers funcionando
- [ ] Fórmulas testeadas
- [ ] Unit tests para UseCases principales
